\documentclass[10pt]{article}
\usepackage{textcomp}
\usepackage{bookman}
\usepackage{graphics}
%\usepackage{html, makeidx}

\newcommand{\ita}[1]{\emph{#1}}

\newcommand{\cpsw}      {\ita {CPSW}}
\newcommand{\yaml}      {\ita {YAML}}
\newcommand{\entry}     {{Entry}}
\newcommand{\field}     {{Field}}
\newcommand{\entries}   {{Entries}}
\newcommand{\entryimpl} {{EntryImpl}}
\newcommand{\hub}       {{Hub}}
\newcommand{\hubs}      {{Hubs}}
\newcommand{\Path}      {{Path}}
\newcommand{\Paths}     {{Paths}}
\newcommand{\git}       {{\tt{}git}}
\newcommand{\py}        {python}
\newcommand{\pyt}       {python}
\newcommand{\udps}      {udpsrv}
\newcommand{\cpp}       {C++}

\newcommand{\cod}[1] {{\tt#1}}

\newcommand{\tutyaml} {\cod{tutorial.yaml}}

\newcounter{figs}
\newcounter{tbls}

\newcommand{\fig}[2]{
\refstepcounter{figs}
\hspace*{\fill}\resizebox{#1}{!}{\includegraphics{#2}}\hspace*{\fill}
}

\newcommand{\figr}[1]{Fig.~\ref{fig:#1}}

\title{A \cpsw{} Tutorial}
\date{Version: \input{gitversion.tex}}

\begin{document}
\maketitle

\section{Introduction}
The ``Common Platform Software'' is a package which facilitates communication with
common platform firmware. It is intended to provide basic access to firmware features
while hiding details of the communication protocols involved. \cpsw{} implements
abstractions for entities like registers and devices and hides low-level details such
as addressing or routing information, byte-order etc.

\cpsw{} uses a description of a device hierarchy -- which often is generated by the
hardware engineer -- in \yaml{} format. This description encodes all the low-level
information and is interpreted by \cpsw{}. \cpsw{} generates an internal representation
of the hierarchy and offers the user access via the {\em \cpsw{} User API}.

In this API the hierarchy is represented as a hierarchy of nodes (``{\em \entries}'')
and the hierarchy is navigated by means of ``\Path{}'' objects. All \entries{} have
{\em names} and can be located by name lookup. Hierarchies are built out of container-
elements -- so called \hub{}s -- and leaf nodes.

Some of the \entries{} implement {\em interfaces}. These interfaces offer additional
functionality such as reading or writing values, executing commands or reading bulk data.

Because of the limited support for reflection in \cpp{} the user normally must either
know what kind of interface an \entry{} supports (hardware documentation) or inquire
by trying to open the desired interface on an \entry{}.

It is important to note that \cpsw{} is essentially {\em state-less}. This is intentional
because complex systems are usually built on top of \cpsw{} and software like {\em EPICS}
already offer powerful tools for building and managing stateful systems.

In this tutorial we shall explore the major aspects of \cpsw:
\begin{itemize}
  \item  Navigating the hierarchy; \Path{}s and interfaces.
  \item  Defining a hierarchy in YAML.
  \item  Using \cpsw{} to interact with a remote system.
  \item  Creating a new \cpp{} class which extends \cpsw{}'s core functionality.
\end{itemize}

For the tutorial we will use the {\em \py} binding of \cpsw{} but the reader
is encouraged to try to reproduce some of the steps in \cpp{} as well.

\section{Prerequisites}
In order to work through this tutorial the reader is expected to have a working
knowledge of
\begin{itemize}
  \item \cpp{}
  \item \py
  \item YAML
  \item linux (as an operating-system user; launch commands, execute compilers etc.)
\end{itemize}

The user should have a fresh copy of this tutorial checked out from \git{} and built
the version of \cpsw{} which comes with it (in the \cod{framework} subdirectory).
When building from a \git{} checkout then some of the documentation must
be generated which requires
\begin{itemize}
  \item \cod{pdflatex}
  \item \cod{fig2dev}
\end{itemize}

You will need a recent toolchain and \py{}2.7 or 3.

\subsection{Building \cpsw}
The tutorial comes with its own check-out of \cpsw{} -- this allows you to browse 
around and make changes etc. without interfering with other people. Building \cpsw{}
yourself also familiarizes you with the make process which shall be used again
when we create our own \cpp{} class.

First, you need to point the makefile to the locations where the libraries used by
\cpsw{} are installed
\begin{itemize}
\item \cod{yaml-cpp}
\item \cod{boost}
\item \cod{\py}
\end{itemize}
For the installation at SLAC, the relevant locations of \cod{yaml-cpp} and \cod{boost}
are already defined in the file \cod{config.mak} (in the \cod{framework} subdirectory).
However, at the time of this writing the location of \cod{\py} has not been defined
and we shall do that now.

It is also important that later, when you launch \py{}, you use the same version
of the \py{} interpreter that was used to build the \py{} \cpsw{} module.

We will create a new file, \cod{config.local.mak}, (located also in the \cod{framework}
subdirectory) from where we can override settings defined in \cod{config.mak}.
\cod{config.local.mak} is intended to be used for local modifications which will
never be recorded in \cod{git}.

We also define a \cod{INSTALL\_DIR} in this file and we restrict the build to
just the host architecture. These are the contents of your new
\cod{config.local.mak}\footnote{We used a \cod{define} statement rather
than a straight variable assignment for cosmetic reasons only. It allows this
snippet of code to be properly typeset without producing overfull lines.}
\begin{verbatim}
INSTALL_DIR=$(CPSW_DIR)/../
ARCHES=$(HARCH)
define py_DIR_default
/afs/slac/g/lcls/package/python/python2.7.9/$(TARCH)
endef
pyinc_DIR_default=$(py_DIR)/include/python2.7
\end{verbatim}

Now you can change back to the tutorial's top directory and type \cod{make install}.
The file \cod{INSTALL} provides more information about \cpsw{}'s
makefile system (\cite{INSTALL, makefile}).

\subsection{Starting \cod{\py}}
We will now discuss how \cpsw{}'s \py{} interface can be loaded. In order for
\py{} to be able to find this interface you need to point the environment variable
\cod{PYTHONPATH} to the location where \cod{pycpsw.so} is installed
(\cod{<top>/bin/linux-x86\_64}).

Because \cpsw{} requires other libraries (most notably \cod{yaml-cpp} and \cod{boost})
the run-time linker must also be able to find these libraries which is normally
accomplished by the linux system administrator configuring the linker's database
accordingly (``\cod{ldconfig}'').

However, in our case \cod{yaml-cpp} and \cod{boost} are custom built and the linker
does not know about them. Therefore you must explicitly ``tell'' the linker by setting
the \cod{LD\_LIBRARY\_PATH} environment variable.

The file \cod{env.slac} contains suitable definitions for the \cod{bash} shell which
you can simply ``source'' into the shell. You'll need to do this for every session:

\begin{verbatim}
bash
. env.slac
python
\end{verbatim}

Note that \cod{env.slac} also adds to the \cod{PATH} environment variable so that
the correct version of the \py{} interpreter is used.

Once the interpreter is up enter:

\begin{verbatim}
import pycpsw
\end{verbatim}

After this command completes successfully you are able to use the \cpsw{} interface.
Otherwise you need to make sure
\begin{itemize}
\item There were no build errors.
\item The \cod{pycpsw.so} file got installed (\cod{make install}).
\item The variable definitions in '\cod{env.slac}' are up to date.
\item \cod{env.slac} was in fact ``sourced'', i.e., the variables defined in the
      file are present in your shell (use \cod{printenv} to check).
\end{itemize}

\subsection{Starting \udps}
\cpsw{} comes with the \cod{\udps} server program which emulates the communication
protocols used by \cpsw{} and implements emulations of some simple devices. For this
tutorial we shall employ \udps{} which means that we do not need to set up special
hardware and are independent of network configurations etc.

You need, however, to start \udps{} in order to execute the examples discussed in
the tutorial. \udps{} requires the same \cod{LD\_LIBRARY\_PATH} settings which have
been mentioned already. Open a new terminal, change directory to the tutorial's
top and type
\begin{verbatim}
. env.slac
bin/linux-x86_64/udpsrv -T 8400
\end{verbatim}
The server will open UDP port 8400 where it is listening for requests. Because
only a single program may listen on a given port this means that only a single
instance of \udps{} may be started using the same port number on any machine.
If 8400 is already in use then you have to try a different number. {\em Note
that in this case you will have to modify the YAML definition file
(see next section) accordingly.}


\section{First Steps with \cpsw}
\label{sec:firststeps}
In this section we load a \yaml{}-file which defines a device hierarchy.
The \yaml{} file \tutyaml{} in the \cod{yaml} subdirectory contains
definitions which describe the protocol stack implemented by \cod{\udps}.
If you started the server on a different port then you need to edit the
file; look for a \cod{UDP} section and modify the port number to match
the \cod{-T} argument.

In \py{}, type

\begin{verbatim}
>>> import pycpsw
>>> root = pycpsw.Path.loadYamlFile("yaml/tutorial.yaml")
\end{verbatim}

\cod{root} now refers to a \cpsw{} \Path{} object which represents
the root of the device hierarchy.

\subsection{Help}
The \py{} bindings support basic documentation. For any class or member
you can invoke \cod{help(<item>)}:
\begin{verbatim}
>>> help(pycpsw.Path.loadYamlFile)
Help on built-in function loadYamlFile:

loadYamlFile(...)
<FURTHER OUTPUT NOT QUOTED HERE>
\end{verbatim}
or
\begin{verbatim}
>>> help(root)

Help on class Path in module pycpsw:

class Path(Boost.Python.instance)
<FURTHER OUTPUT NOT QUOTED HERE>
\end{verbatim}

\subsection{Paths}

An important functionality of \Paths{} is the possibility to lookup
descendents. Type

\begin{verbatim}
>>> apath = root.findByName("mmio/folder/hello")
\end{verbatim}

You can convert a \cod{Path} to a string representation:

\begin{verbatim}
>>> print( apath.toString() )
/mmio/folder[0-1]/hello[0-9]
\end{verbatim}

The numbers ``[0-1]'' and ``[0-9]'' represent {\em array bounds} which 
are zero-based and include the last element. This means that there are
actually two instances of `\cod{folder}' present under `\cod{mmio}' and
an array of 10 \cod{hello}s in each \cod{folder} which amounts to
20 \cod{hello}s total:

\begin{verbatim}
>>> apath.getNelms()
20
\end{verbatim}

When performing a path lookup without explicitly specifying bounds then
the operation will always include {\em all} instances found.

It is possible to select only a subset of array elements:

\begin{verbatim}
>>> spath = root.findByName("mmio/folder[1]/hello[3-8]")
>>> spath.getNelms()
6
>>> spath.toString()
'mmio/folder[1]/hello[3-8]'
\end{verbatim}

Thus, a \Path{} identifies not only a hierarchical ``address''
of an entity but also defines multiple levels of array bounds.

A \Path{} can be duplicated with `\cod{clone()}' and its last element
can be stripped with `\cod{up()}':

\begin{verbatim}
>>> tpath = spath.clone()
>>> tpath.up()
<pycpsw.Child object at 0x7f13d8b977c0>
>>> tpath.toString()
'/mmio/folder[1]'
\end{verbatim}

The default lookup operation is not very smart. It does not support features
like wildcards or regular expressions. Using the `\cod{explore()}' method it is
possible to implement such functionality. \cod{explore()} expects an \cod{IPathVisitor}
(see \cod{cpsw\_api\_user.h}, \cite{userapi}) callback argument to implement 
\begin{verbatim}
virtual bool visitPre (ConstPath here);
virtual void visitPost(ConstPath here);
\end{verbatim}

\cod{explore} recurses through a hierarchy and executes \cod{visitPre()} {\em prior}
to recursing into children and \cod{visitPost()} {\em after returning} from recursion
into children. If \cod{visitPre()} returns \cod{false} then recursion into children
is skipped (but \cod{visitPost()} is still called).

\cod{pathGrep.py} is a simple example demonstrating how searching for \Paths{} which match
a regular-expression pattern can be implemented. It is left as an exercise to the reader
to improve the implementation by avoiding unnecessary recursion (hint: use the \cod{regex}
packages' \cod{partial} feature to check whether the `here' Path could potentially match
and let \cod{visitPre} return \cod{False} if this is not the case).

\begin{verbatim}
>>> import pathGrep as pg 
>>> pg.pgrep(root,None)
\end{verbatim}

will print the entire hierarchy.

\subsection{Entries and Hubs}
Every object in the \cpsw{} hierarchy is represented by an {\em \entry{}}. \entry{} presents
a rather high level of abstraction and provides just enough information for navigating
the hierarchy, i.e., \cod{getName()}. For convenience, there is also \cod{getDescription()}
which returns a description string -- if the designer of the YAML hierarchy has supplied
one. {\em \hubs{}} are \entries{} which can contain a collection of children.

You can obtain a handle to the \entry{} reached by a \Path{} using \cod{tail()}
(and the \cod{up()} method which we saw before actually returns the \entry{} that
it strips off):

\begin{verbatim}
>>> apath.tail().getName()
'hello'
>>> apath.tail().getDescription()
'This is the description of hello'
\end{verbatim}

Note that \entries{} by themselves are not very useful unless they are contained in
a \Path{} which uniquely identifies the \entry{} and also encodes array index
ranges (or ``bounds'').
Very much like a \yaml{} alias node the same \entry{} may be present at
multiple places in the hierarchy and only the \Path{} which describes how to reach
an \entry{} contains all the necessary information to perform advanced operations.

\subsection{Interfaces of Entries}
The really meaningful operations carried out on \entries{} use {\em Interfaces}.
An interface is an abstract class with a set of defined methods. A given \entry{}
may implement multiple interfaces and conversely: any interface may be implemented
by different \entries{}.

\cpsw{} defines a few commonly used interfaces for accessing integers ({\em ``ScalVal''}),
floating-point numbers ({\em ``DoubleVal''}), executing commands or user-defined code
({\em ``Command''}) and accessing bulk data ({\em ``Stream''}). However, additional
interfaces may be defined by the user and added to \cpsw{}.

An interface is created or ``opened'' as follows:
\begin{verbatim}
>>> intrf = pycpsw.<interface>.create( path )
\end{verbatim}
where \cod{<interface>} is to be substituted by the name of the desired interface.
If the \entry{} at the tail of the \Path{} actually implements the desired interface
then \cod{intrf} will now be a handle to that interface. If the interface is not
implemented then a \cod{InterfaceNotImplementedError} is thrown.

Due to the limited support in \cpp{} for reflection it is currently not possible to 
inquire the number and type of interfaces supported by an \entry{}. However, in
order to do useful work the user must have an idea of the underlying functionality
anyways.

We are now ready to try this
\begin{verbatim}
>>> hello = pycpsw.ScalVal.create( apath )
\end{verbatim}
The ``hello'' array is -- on the server -- memory backed and probably initialized
to random bit patterns.

We can read these back first and then set to the range $1..20$ using {\em ScalVal}'s
\cod{getVal()} and \cod{setVal()} methods:
\begin{verbatim}
>>> hello.getVal()
[4289956834,  548862927, 1795124846,  171206389,
 1363892794,  899570001, 3744639575, 1205068551,
 2941190523, 4152934318, 4241579523, 1726526404,
 2081186026, 3042882507,  316511701,  106114807,
 2428654618, 153782231, 1181565810, 1022839516 ]
>>> hello.setVal( list(i for i in range(1,21)) )
20
>>> hello.getVal()
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
\end{verbatim}

Let us now play with the restricted \Path{} `\cod{spath}' (see above).
It only selects elements 3-8 of the second `\cod{folder}':
\begin{verbatim}
>>> spath.toString()
'/mmio/folder[1]/hello[3-8]'
>>> subHello = pycpsw.ScalVal.create( spath )
>>> subHello.getVal()
[14, 15, 16, 17, 18, 19]
\end{verbatim}

If \cod{setVal()} is given a scalar then all array elements are written
with the same value:
\begin{verbatim}
>>> subHello.setVal(0)
6
>>> hello.getVal()
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12, 13, 0, 0, 0, 0, 0, 0, 20]
\end{verbatim}
As the second result shows, indeed only elements addressed by `\cod{spath}'
are affected. The return value of \cod{setVal()} also indicates that 6 elements
were written.

Array bounds can be further reduced (i.e., without constructing a new \Path{})
by passing `\cod{fromIdx}' and `\cod{toIdx}' arguments to \cod{getVal()} and
\cod{setVal()}, respectively.
However, only the rightmost index can be reduced with this method.

Note that `\cod{fromIdx}' and `\cod{toIdx}' operate {\em within} or {\em based-off}
the index range already selected by the \Path{}. E.g., when we say

\begin{verbatim}
>>> subHello.setVal(88, fromIdx=2, toIdx=4)
3
>>> hello.getVal()
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12, 13, 0, 0, 88, 88, 88, 0, 20]
\end{verbatim}

then it can be seen that `\cod{fromIdx}' starts at offset 2 from the (rightmost)
index in the path which is 3. Since this path only selects the second
`\cod{folder}', there are only 3 elements to be written starting at offset
$10+3+2=15$. A single element can be addressed by omitting \cod{fromIdx}
(or setting it equal to \cod{toIdx}).

\subsection{A look at \yaml{}}
We encourage you now to open the file \tutyaml{} and take a look.
Locate the '\cod{hello}' \entry{}. You will find that it is of class `IntField'.
This is a class which implements the `ScalVal` interface we had used in the
last section. You see that 10 elements (``nelms: 10'') of `hello' are present.
The containing `\cod{folder}' (of which 2 elements are present) is of class `MMIODev'.
The latter is a container class which implements memory-mapped addressing. Each of
its children is attached at a memory-mapped `offset'. MMIODev containers
may be nested, i.e., a large memory-mapped area may contain sub-areas and
the `\cod{folder}' is indeed such a sub-area. An array of two `\cod{folder}'s is
present in the top-level `\cod{mmio}' area starting at offset 0.
By default, children of MMIODev are `spaced' by their size, i.e., folder[1] is
at offset 0x400.

Now look at the second child of `\cod{folder}'. It is again an `IntField' -- named
`\cod{menu}'.  It defines the following properties:
\begin{verbatim}
at: { offset: 0x000001 }
sizeBits: 2
lsBit:    4
enums:
  - { name:  zero, value: 0 }
  - { name:   one, value: 1 }
  - { name:   two, value: 2 }
  - { name: three, value: 3 }
\end{verbatim}
This illustrates the following points:
\begin{itemize}
\item An IntField may have any bit size (up to currently 64).
\item Its 'bits' need not be aligned with a byte boundary (lsBit: 4). The
      `lsBit' property defines the number of bits the least-significant bit
      is left-shifted within `its' byte.
\item An optional 'enum' menu can be associated with an IntField. This
      menu associates integer values with strings.
\item Note that '\cod{menu}' starts at byte offset $1$ in the containing MMIODev.
      Legal bit offsets of the least-significant bit are $0..7$, i.e., you
      must anchor the IntField at the correct byte-address and use `lsBit'
      only for ``sub-byte'' shifting.

      Be careful when dealing with IntFields in big-endian layout. The byte-address
      of the IntField must still be the first byte which overlaps the IntField. E.g.,
      if you have a 12-bit field in big-endian layout with the most-significant
      bit lined up at a byte boundary e.g., at offset $0$ in a MMIODev then the
      following setup would describe this configuration:
\begin{verbatim}
at: { offset: 0 }
byteOrder: BE
bitSize: 12
lsBit: 4
\end{verbatim}
      The register layout is depicted in \figr{byteorder} along with the corresponding
      little-endian configuration:
\begin{verbatim}
at: { offset: 0 }
byteOrder: LE
bitSize: 12
lsBit: 4
\end{verbatim}
	  As it can be seen, in both cases, the offset defines the byte-offset of the
      lowest byte in memory overlapping the IntField and the shift defined by `lsBit` 
      is the amount by which the least-significant bit is left-shifted with respect
      to the byte boundary, regardless of the byte-order.
\end{itemize}

\begin{figure}[ht]
\fig{0.95\textwidth}{O.Common/byteorder.pdf}
\label{fig:byteorder}
\caption{A 12-bit register with its most-significant bit aligned on a byte boundary. Shown in big- and little-endian layout.}
\end{figure}

\subsubsection{Trying an Enum Menu}
After this glimpse we go back to \py{} and manipulate the enum:
\begin{verbatim}
>>> menu = pycpsw.ScalVal.create(
...               apath.findByName("../menu") )
>>> menu.getVal()
['zero', 'zero']
>>> menu.setVal( ['one', 'two'] )
2
\end{verbatim}
Now try
\begin{verbatim}
>>> hello.setVal(-1,fromIdx=0,toIdx=0)
2
>>> menu.getVal()
['three', 'three']
\end{verbatim}
Apparently, the memory regions covered by `\cod{hello}' and `\cod{menu}' overlap (this is
obvious since \cod{hello} starts at offset 0 with a size of 32-bits (default)
and \cod{menu} starts at offset 1).
\begin{verbatim}
>>> hello.getSizeBits()
32
>>> menu.setVal('zero')
2
>>> for i in hello.getVal(toIdx=0):
...   print('{:x}'.format(i))
...
ffffcfff
ffffcfff
\end{verbatim}
The two \cod{menu} bits have now been merged into the \cod{hello} values.
Since the byte-offset of \cod{menu} was 1 and the bit shift amounted to 4 bits
we find the 2 bits shifted by 12 bits in the 32-bit, little-endian
\cod{hello} value.

{\em Note:} \cpsw{} does {\em not} provide any guards against multiple users
accessing such overlapping definitions (or accessing multiple registers in the
same device etc.). While the underlying SRP protocol executes each transaction
atomically, no other protections are implemented and it is the user's responsibility
to create and observe mutual exclusion protocols where necessary.

Remember that it is not possible to access only a single \cod{menu} array item
with fromIdx/toIdx because these allow only to restrict the rightmost index.
However, the multiplicity of \cod{menu} has origin in the two \cod{folder} instances
-- which are at a higher level in the hierarchy. Therefore, you would have to create a
new ScalVal interface from a suitable \Path{} object in order to manipulate
a single \cod{menu} instance only.

\cod{fromIdx/toIdx} are mainly intended to support indexing large arrays of data
residing at the leaves of the hierarchy.

\section{Interacting with a Device}

It is now time to look at a more realistic example. For that purpose the \udps{}
provides a simulation of a ``pendulum on a cart'' system as depicted in \figr{geom}.

\subsection{Description of the Simulated Target}

\begin{figure}[ht]
\fig{0.5\textwidth}{O.Common/geom.pdf}
\label{fig:geom}
\caption{A pendulum (mass $m$ at the end of a mass-less arm of length $l$) is connected
to a cart (mass $M$) which can move horizontally. An external force $F$ can be applied
to the cart. The position of the cart, $x$, and the angle sustained by the pendulum,
$\varphi$, can be read from ``sensors''.}
\end{figure}

The simulator provides a few memory-mapped registers which give access to the
position readback, the setpoint for the external force as well as some parameters
for the simulation. These registers are summarized in Table~\ref{tbl:regs}.
Since 32-bit integer values are used by the simulator to represent numerical values
these have been scaled to fit the 32-bit range. The scale factor that must be applied
is listed for each register. On readback, a register value has to be multiplied
by the scale factor to yield a scaled number and before writing a register the
value must be converted by dividing by the scale factor.

The simulation can be re-initialized by writing a position/angle to the respective
registers. Note that because multiple 32-bit operations are not carried out atomically
the simulator merely {\em latches} new values for `pos' and `iniVelo' when these
are written. Only when `phi' is written then the simulation is re-initialized
(using the last latched values of `pos' and `iniVelo').

Likewise, when reading `phiRB' then the simulator simultaneously latches the
values for position and time and subsequent reads of these parameters yield the
latched values. Thus, in order to obtain a consistent triple read `phiRB' {\em first}.

All lengths are normalized to half of the horizontal track length which therefore
extends from $pos = x =-1..+1$.

\begin{table}[ht]
\refstepcounter{tbls}
\label{tbl:regs}
\hspace*{\fill}
\begin{tabular}{rrrcl}
         Name &     Offset & Scale        & Signed & Description       \\
\hline
    vFriction & \cod{0x00} & $2^{-32}$    & N & Viscous damping   \\
       gOverL & \cod{0x08} & $2^{-16}$    & N & $g/l$             \\
       mOverM & \cod{0x0c} & $2^{-16}$    & N & $m/M$             \\
       length & \cod{0x10} & $2^{-16}$    & N & Length of pendulum\\
          pos & \cod{0x20} & $2^{-31}$    & Y & Cart position setpoint\\
          phi & \cod{0x24} & $\pi\, 2^{-30}$& Y & Pendulum angle setpoint\\
      iniVelo & \cod{0x28} & $2^{-15}$    & Y & Cart+pendulum initial velocity\\
        force & \cod{0x2c} & $2^{-15}$    & Y & External force\\
\hline
        posRB & \cod{0x30} & $2^{-31}$    & Y & Cart position readback\\
        phiRB & \cod{0x34} & $\pi\, 2^{-30}$& Y & Pendulum angle readback\\
       timeRB & \cod{0x38} & $2^{-8}$     & N & Simulation time readback\\
\end{tabular}
\hspace*{\fill}
\caption{Simulator register summary. All registers are 32-bit; the scale factor has
to be applied when reading (multiply by scale) or writing (divide by scale) register
values.}
\end{table}

\subsection{The Beauty of YAML}
Compiling the information given in Table~\ref{tbl:regs} and writing a driver based
on it can be tedious and error-prone. Also, there is the danger that when some of
the details change it might not be obvious how to propagate such changes into the
driver code.

Last, but not least: once we have a prototype implemented in \py{} and we wanted
to proceed with a \cpp{} version then we'd have to port all these details.

Luckily, \cpsw{} encapsulates most of these steps with the help of \yaml{}. In most
cases, the hardware-engineer already provides all the detailed information which
traditionally would have to be compiled from manuals or header files in standardized
\yaml{} format.

Since we want to adhere to this workflow the author of the simulator also provided
a \yaml{} register description of the simulated device in \cod{yaml/pendsimRegs.yaml}.
This file contains all the details about the device. The only thing that the system
integrator needs to know is where and how the device attaches to the rest of the system.

We have already used the \yaml{} description of the \udps{} server, \tutyaml{}.
\begin{table}[ht]
\refstepcounter{tbls}
\label{tbl:udpsmap}
\hspace*{\fill}
\begin{tabular}{rrrr}
    Simulated Device & Base Address & Size & TDEST (if streaming) \\
\hline
    Bare Memory      & 0x000000     & 0x1000   & n/a \\
    CPSW Testing     & 0x001000     & 0xffe000 &   1 \\
    SPI EEPROM       & 0x100000     & 0x0400   & n/a \\
    Pendulum Sim.    & 0x100400     & 0x0400   &  44 \\
\end{tabular}
\hspace*{\fill}
\caption{Memory map of the \udps{} server.}
\end{table}
From Table~\ref{tbl:udpsmap} we extract the base address \cod{0x100400} of the
pendulum simulation. In order to incorporate the register description we need
to:
\begin{itemize}
\item ``\#include'' the register description \yaml{} from the main \yaml{} file
\item create a new child of the main memory map (\cod{mmio})
\item ``merge'' the register definition alias
\item define the base-address/offset of the simulator
\end{itemize}

Here are these steps explained in more detail

\begin{enumerate}
\item Only the header section up to the first line which does not start with a `\#'
      are scanned for ``\#include'' directives. Make sure there are no empty lines
      present (but lines containing just a `\#' in the first column are fine) ahead
      of what you are about to add to the header section of \tutyaml{}:
\begin{verbatim}
#include pendsimRegs.yaml
\end{verbatim}
      Make sure there is no blank space neither before nor after the `\#'.

\item Add the following lines to the `children' of `mmio':
\begin{verbatim}
        pendsim:
          <<: *pendsimRegisters
          at: { offset: 0x100400 }
\end{verbatim}
      Make sure the line `pendsim' has the {\em same indentation level} as the
      line containing `folder'. Also, be careful not to paste the new lines ``into
      the middle'' of the lines which make up the definition of `folder' and its
      children. The `pendsim' entry has to be entered either before or after `folder'
      and at the same indentation level. Avoid tabs, use only blanks and make sure
      a blank is present after any `:' in order to separate map keys from values.
\end{enumerate}

More information about the \yaml{} syntax and the schema used by \cpsw{} as
well as the \cpsw{}-specific preprocessor syntax can be found in \cite{yaml,yamlDefinition}.

\subsection{Trying it Out}
Start a new \py{} session and load the \tutyaml{} file as described above.
You should now be able to communicate with the simulator. Proceed and
create two interfaces `\cod{phiSP}' (setpoint) and '\cod{phiRB}' (readback).

You will see a message about a missing shared object which you can ignore --
more about that later.

\begin{verbatim}
>>> root=pycpsw.Path.loadYamlFile("yaml/tutorial.yaml")
>>> phiSP=pycpsw.DoubleVal.create(
...               root.findByName("mmio/pendsim/phi")
... )
>>> phiRB=pycpsw.DoubleVal_RO.create(
...               root.findByName("mmio/pendsim/phiRB")
... )
\end{verbatim}

Since we will be operating with floating-point numbers we instantiated
a `DoubleVal' interface. The readback is read-only and therefore we have
to open the read-only interface `DoubleVal\_RO'.

Check out the readback value:

\begin{verbatim}
>>>phiRB.getVal()
-534217089.0
\end{verbatim}

Obviously, \cpsw{} has taken notice that this is a signed number (check the
\yaml{} description which marks this register as `signed'). All we need to do
is apply the proper scale from Table~\ref{tbl:regs}:

\begin{verbatim}
>>> phiRB.getVal()/2**30
-0.4992395518347621
\end{verbatim}

This result is now in units of $\pi$; a look at \figr{geom} confirms that this
makes sense. The pendulum has come to rest and hangs down ($\varphi=-\pi/2$).

We can initialize the pendulum to a new position ($\varphi=0.8\pi$) and verify
that it is moving (remember that reading/writing \cod{phiSP}/\cod{phiRB} is what
triggers the simulator).

\begin{verbatim}
>>> phiSP.setVal(.8*2**30)
1
>>> phiRB.getVal()/2**30
0.9794269455596805
>>> phiRB.getVal()/2**30
1.163966953754425e-05
>>> phiRB.getVal()/2**30
-0.9597937744110823
>>> phiRB.getVal()/2**30
-0.13837423734366894
\end{verbatim}

\subsection{Exercise: Writing the CPSW Interface in Python}
The python script `\cod{tutorialGui.py}` uses PyQt4 to display the simulated
system in motion. It also provides Gui elements to control the model parameters.

The Gui relies on another script, `\cod{UdpsrvInterface.py}', which implements
a thread for periodically reading simulation time, angle and position from the
simulated device in order to update the display. It also keeps a dictionary of 
the parameters which can be accessed via \cpsw{}.

\cod{UdpsrvInterface.py} in turn uses a class `\cod{\mbox{ModelParm}}'
which does the actual interaction with \cpsw{}. The scripts are structured such
that this class -- which the reader is expected to implement as an exercise -- is kept
as simple as possible. Each instance of a \cod{\mbox{ModelParm}} object shall represent
a single parameter which interfaces to an underlying register from Table~\ref{tbl:regs}.

\begin{enumerate}
\item Create a file `\cod{ModelParm.py}' where you implement the \cod{\mbox{ModelParm}} class.
\item The constructor method (\cod{\_\_init\_\_()}) takes two arguments (in addition
      to the usual \cod{self}):
    \begin{itemize}
    \item `\cod{prefix}' which is a reference to a \cpsw{} \Path{} object leading
          to the \cod{pendsim} device which was defined in \yaml{}.
    \item `\cod{name}', the name of the register (see Table~\ref{tbl:regs}).
    \end{itemize}
    The constructor should create a `DoubleVal' (setpoints) or `DoubleVal\_RO' for
    readbacks, respectively, and store the reference in the \cod{\mbox{ModelParm}}'s
    \cod{self} handle.
\item Define a `\cod{getDescription()}' method which calls the associated DoubleVal's
    \cod{getDescription()} method and propagates the returned description string.
\item Define a `\cod{getVal()}' method which calls the associated DoubleVal's
    \cod{getVal} method, applies the appropriate scale factor from Table~\ref{tbl:regs}
    and returns the scaled value.
\item Define a `\cod{setVal()}' method which takes (in addition to the usual \cod{self})
    a single (float) argument which needs to be scaled by the factor from
    Table~\ref{tbl:regs} and passed down to the associated DoubleVal's \cod{setVal()}.
\end{enumerate}

It is worthwhile studying the section of the constructor of the \cod{Model} class
(in \cod{UdpsrvInterface.py}) where the \cod{\mbox{ModelParm}} objects are instantiated:
\begin{verbatim}
for child in self.modl.tail().isHub().getChildren():
  nam             = child.getName()
  self.parms[nam] = ModelParm.ModelParm( self.modl, nam )
\end{verbatim}
As you can see, the code iterates over the children of \cod{modl} (which is
a reference to the \cod{pendsim} device), retrieves their names and creates
a \cod{\mbox{ModelParm}} for each of them. This is an example for how GUI elements
can be created in an automatic fashion from \cpsw{}.

\subsection{Launching the GUI}
You can now launch the Gui and test your \cod{\mbox{ModelParm}} class. Remember that the
environment variables discussed earlier need to be set:
\begin{verbatim}
  python tutorialGui.py
\end{verbatim}
The Gui should be started from the tutorial top directory in order to locate
dependent \yaml{} and \py{} files (including your \cod{\mbox{ModelParm.py}}).

\section{Working with Streams}
A stream provides direct access to bulk data on a remote device. Data are
presented to the user after passing through the (optional) RSSI, packetizer
and TDEST demultiplexing layers as a sequence of raw datagrams (i.e., \cpsw{}
does not further interpret or manipulate the data and passes them ``as-is''
on to the user).

The pendulum simulator device does implement a stream where it feeds position
and angle readings. I.e., instead of periodically polling the current position
readback our application may `{\em listen}' to a stream.

The simulator provides (unsolicited) readings of the simulation time, the pendulum
angle and the horizontal position over a streaming interface. The data format
of the streamed message is shown in Table~\ref{tbl:strmmsg}. The time, angle and
position are stored in {\em little-endian} byte-order as 64-bit, fixed-point numbers
which can be converted into floating-point representation by division by $2^{32}$.
Note that this scale factor is common to all elements and {\em different} from the
scales in Table~\ref{tbl:regs}.

\begin{table}[ht]
\refstepcounter{tbls}
\label{tbl:strmmsg}
\hspace*{\fill}
\begin{tabular}{rrl}
Address & LSB, Byte 1, Byte 2 ... Byte 7      & Byte 8 \hfill ... \hfill MSB \\
\hline
0x00    & Time      \hfill (fractional part)  & Time \hfill (integer part) \\
0x08    & $\varphi$ \hfill (fractional part)  & $\varphi$ \hfill (integer part) \\
0x10    & $x$       \hfill (fractional part)  & $x$       \hfill (integer part) \\
\end{tabular}
\hspace*{\fill}
\caption{Layout of the stream datagram containing simulator state information. The
64-bit numbers are a fixed-point representation with the radix point located between
bits 31 and 32.}
\end{table}

\subsection{Defining a Stream in \yaml}
The first thing we need to do is to add a definition of the streaming Interface to
our \yaml{} file.

The first questions are ``where is this definition to be added'' and ``what
information is required''? We might be tempted to answer the first of these questions
by proposing to add the stream definition to the ``pendsim'' device definition.

However, this device describes a memory-mapped entity and its register details
etc. -- but the streaming channel is actually rather independent from the device
registers (similar to an interrupt line of a PCI device which can be routed
independently from PCI on a motherboard). The streaming channel is actually
originating directly at the {\em communication device}. (Again the analogy of
the interrupt line which may be connected directly to a central interrupt controller.)

In fact -- the details of the stream communication are dominated by choices made
by the system integrator rather than the device designer. A stream can use a separate
communication channel (e.g., UDP port) altogether or share parts of the communication
stack with the memory-mapped devices. For this reason, a streaming interface can
often not entirely be defined by the device-specific \yaml{} file.

In the case of our example the stream actually shares many protocol layers but
is eventually demultiplexed based on a ``TDEST'' identifier: $44$. The main \tutyaml{}
file defines a `StreamProtoConfig` alias node with all the common definitions
applicable to streams (as implemented by \udps{}) except for TDEST.

Now open the \tutyaml{} file and add the following definition {\em as a sibling of
`mmio'} (again: pay careful attention to indentation levels and avoid TABs):
\begin{verbatim}
    pendsimStream:
      class: Field
      at: {       <<: *StreamProtoConfig,
            TDESTMux: { TDEST : 44 }     }
\end{verbatim}

Note that while the the `pendsim' device (the registers) is
a {\em child} of `mmio' the stream is a child of the {\em `root'}
node.

\subsection{Reading from a Stream}
With the streaming interface now defined in \yaml{} we can proceed to exercise
the stream.  Begin with loading the \tutyaml{} file into \py{} (see
section~\ref{sec:firststeps}).  A streaming interface is -- similar to any other interface
in \cpsw{} -- opened from a \Path{}.
\begin{verbatim}
>>> strm=pycpsw.Stream.create(
...             root.findByName("pendsimStream")
... )
\end{verbatim}

The \py{} bindings require an object which supports the (so called ``new'') buffer
interface (consult the \py{} documentation for more information) to be passed to
the stream's `\cod{read()}` (or `\cod{write()}`) method.
In \pyt{} we may use an \cod{array} object (\cod{numpy.ndarray} is another option).
Since we are dealing with three 64-bit numbers we create an array of quads:
\begin{verbatim}
>>> import numpy
>>> data=numpy.ndarray(3,dtype=numpy.int64)
\end{verbatim}
and read from the stream (the return value is the number of bytes read):
\begin{verbatim}
>>> with strm:
...   strm.read(data)
...
24
\end{verbatim}
Note that the \cod{data} array now contains the raw data. If the host computer does not
use `little-endian' representation then the raw data need to be byte-swapped.

Note that you cannot read from the stream without a \cod{with} statement:
\begin{verbatim}
>>> strm.read(data)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
pycpsw.FailedStreamError: Stream can only be...
used from the block of a 'with' statement!
>>> 
\end{verbatim}

We extract the angle and convert to a floating point number (see
Table~\ref{tbl:strmmsg}):
\begin{verbatim}
>>> phi = float(data[1])/2.**32
>>> phi
-1.5706
\end{verbatim}
The pendulum is apparently hanging in its equilibrium position.

\subsubsection{A ``Strange Phenomenon''}
Why did we have to use the \cod{with} construct for reading from the stream?
Let's explore this in more detail. First, we want to be able to execute
individual steps inside \cod{with} interactively. To that end we start a
sub-interpreter:
\begin{verbatim}
import code
with strm:
...  code.interact(local=locals())
...
\end{verbatim}
After terminating the empty continuation line you are now in a sub-shell
``inside'' the with statement. You can now read the stream directly:
\begin{verbatim}
>>> strm.read(data)
24
\end{verbatim}

From the same session that uses the streaming interface you could now try to
read the angle from the corresponding readback register:
\begin{verbatim}
>>> phiRB = pycpsw.ScalVal_RO.create(
...                root.findByName("mmio/pendsim/phiRB")
... )
>>> phiRB.getVal()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
pycpsw.IOError: No response -- timeout
\end{verbatim}
After issuing the \cod{getVal()} command nothing happens for a while and eventually
a timeout error occurs. What is going wrong? The cause for this behavior is the
configuration of the communication stack which {\em shares} the {\em RSSI} (reliability) layer
between the stream and register access. RSSI guarantees reliable in-order delivery
of all traffic. Because we are not consuming all the streaming messages as they arrive
the output queue of \cod{pendsimStream} fills up and prevents RSSI from delivering
more messages. Since RSSI must deliver {\em all} messages in order (the demultiplexing
of streaming messages and register transactions is done at a higher protocol level)
it eventually stalls (and puts back-pressure on the streaming data producer).
However, as a side-effect, register transactions are also stalled.

To remedy the situation we can {\em close} the streaming interface. In the \cpp{} API
this is achieved by releasing all shared pointers to the stream in question.
In \py{} this is not necessarily enough since garbage collection 
may happen at a later time. Therefore the need for the \cod{with} statement
and a python ``context manager'' which closes the stream at a well-defined
point, namely when the \cod{with} block ends. Remember now that we are
still inside the sub-interpreter nested into the \cod{with} block. If we terminate
the sub-interpreter by hitting \cod{Ctrl-D} then we leave the \cod{with} block,
release the stream and are able to 
\begin{verbatim}
>>> <Ctrl-D>
>>>
>>>float(phiRB.getVal())/2.**30*3.141592659
-1.5707972482125554
\end{verbatim}

The lesson to be learned here:
\begin{itemize}
\item Only instantiate a streaming interface if you are consuming data.
\item Consume all streamed data.
\item Release all shared pointers to a streaming interface when you no longer
      need it.
\item In \py{} you can access streams only inside a \cod{with} block. Typically
      such a block contains a read-loop.

      In \py{} \cod{Stream.create()} actually creates a so-called ``context-manager''
      which manages the underlying \cpp{} object, creating and destroying it
      whenever the context is entered or left, respectively.
\end{itemize}

\subsection{Exercise}
As an exercise you should write a small \py{} class which ``glues'' the
stream fed by \udps{} into \cod{UdpsrvInterface.py}.
\begin{enumerate}
\item In the tutorial's top directory create a file `\cod{StreamHandler.py}' where you
      define a `\cod{StreamHandler}' class.
\item The constructor (\cod{\_\_init\_\_()}) takes as a single argument (in addition
      to \cod{self}) a \Path{} representing the root of the \cpsw{} hierarchy.

      The constructor shall open/create the streaming interface and store its
      reference in \cod{self}. Also, an array object with three 64-bit elements
      shall be pre-created and attached to \cod{self}.

      Optionally, a boolean flag shall be set (in \cod{self}) indicating whether
      byte-swapping is required.
\item The class shall define a \cod{read()} method which takes a single (in
      addition to \cod{self}, that is) numerical parameter which communicates
      a timeout (in micro-seconds) for the read operation.

      The \cod{read()} method shall attempt to read from the stream into
      the buffer-array for up to the specified timeout.

      It the read-operation on the stream times out then the method
      shall return \cod{None}.

      If the read-operation is successful then the method shall return a tuple with
      three floating-point values: $time$, $angle$ and $position$ in that order. 
      These values shall be properly scaled (see Table~\ref{tbl:strmmsg}).

      Optionally, byte-swapping shall be performed -- if required as determined
      by \cod{\_\_init\_\_()} -- on the array elements (before converting them into
      floats).
\item The class shall redirect \cod{\_\_enter\_\_()} and \cod{\_\_exit\_\_()}
      methods to the stream member. E.g., if the stream created during
      \cod{\_\_init\_\_()} is stored in \cod{self.strm\_} then
      \begin{verbatim}
def __enter__(self):
  return self.strm_.__enter__()

def __exit__(self, a, b, c):
  return self.strm_.__exit__(a, b, c)
      \end{verbatim}
\end{enumerate}
Use \cite{userapi} and/or \py{} \cod{help()} for more information about the Stream
interface's \cod{read()} method as well as other details you might need to know.

Test this class. Below the graphical window in the Gui the status line should indicate
that streaming is used.

\section{Writing a \cpsw{} \cpp{} Extension}
In this section we shall get an idea of how \cpsw{} may be extended at the \cpp{} level.
In most cases this means extending a subclass of \entryimpl{} (the implementation of \entry{})
in order to implement one of the base interfaces for a different kind of underlying
hardware, e.g., a custom implementation of a `Command' \cite{myCommand}.
Such a class may also introduce new interfaces (consult the `FirmwareLoader' application
-- which is {\em not} part of this tutorial, however -- for an example \cite{FWLoader}).

\cpsw{} provides a number of hooks for such an extension:
\begin{itemize}
\item The extension class should be compiled into a {\em shared object}.
\item The extension, when run-time linked into a \cpsw{} application {\em registers}
      itself with \cpsw{}.
\item A \yaml{} definition may list an extension among the elements of the `class'
      property of a node in the hierarchy.
\item When building the hierarchy, \cpsw{} examines the `class' propery of each node
      it has to create. It performs a lookup of the names listed in the `class' property
      in its registry of built-ins and extensions. If the desired `class' is found
      then creation is delegated to a factory method of the class.
\item If a desired `class' is {\em not} found then \cpsw{} tries to dynamically
      link a shared object with the same name. If this operation is successful then
      it triggers registration of the new extension (see above). \cpsw{} will then -- on 
      a second attempt -- find the desired `class' and subsequently execute its
      factory method to create the new node.
\end{itemize}

\subsection{Extension Design Goal}
With vanilla \cpsw{} we have not been able to transparently use the scale factors.
Although they are present in the \yaml{} register definition the built-in class
(\cod{IntField}) does not make use of them. Instead, we had to {\em manually}
copy them into our \py{} class (\cod{\mbox{ModelParm}}) and apply them when
interacting with \cpsw{}. It would obviously be preferable if \cpsw{} could ``do
the right thing'' under the hood.

Let's therefore create a \cpsw{} extension class which applies a linear transformation
when converting an integer to a floating-point value. The extension should be able
to extract the conversion parameters from \yaml{}.

\begin{figure}[htb]
\fig{0.9\textwidth}{O.Common/classhier.pdf}
\label{fig:classhier}
\caption{Hierarchy of Classes and Interfaces for the CIntEntryImpl/CScalValAdapt\_XX 
implementation of ScalVal/DoubleVal and related interfaces. The ``static'' class
CIntEntryImpl is associated with Adapters CScalValXXAdapt.}
\end{figure}


\subsection{Extending an Existing Class}
The first decision we have to make is: {\em what existing class should we extend}?
Since \cod{IntField} already provides most of the functionality we need it is natural
to use it as a starting point. \cod{IntField}, however, is itself an abstraction. The
actual hierarchy of classes is a bit more complex and we shall return to this in a
moment. But first we explain the concept of a \cpsw{} ``{\em Adapter}'' class.

The purpose of an \entry{} in most cases (including this one) is providing an
{\em interface} for user interaction. As it has been mentioned already, the \entry{}
itself is {\em not} holding the full information required by an interface; it is
a rather ``static'' entity and like the \yaml{}-node from which the \entry{} was
created it may be present at multiple places in the hierarchy. An {\em Adapter}
is a object which contains dynamic information (such as the \Path{}
from which an {\em interface} is created) and it ``glues'' the implementation of
an {\em interface} to an {\em entry} (``Association'' in \figr{classhier}).
Thus, an implementation of an \entry{} in \cpsw{} usually comes as a {\em pair} or
even {\em set} of classes: one class which implements the static aspects such as
interfacing to \yaml{}  and an
{\em Adapter} class for each supported {\em interface} (alternatively, there could
also be a single {\em Adapter} which implements multiple {\em interfaces} -- e.g.,
\cod{CScalVal\_ROAdapt} in \figr{classhier} implements IScalVal\_RO as well
as IDoubleVal\_RO).

The hierarchy of implementation- and interface-classes is depicted in \figr{classhier}.

The class CIntEntryImpl and its associated {\em Adapter}s (dark grey box
at the bottom left of \figr{classhier})
are defined in the files \cod{cpsw\_sval.h} and \cod{cpsw\_sval.cc}. CDoubleVal\_ROAdapt
has a virtual \cod{int2dbl()} method for conversion of integers to floating-point values and
the companion class CDoubleVal\_WOAdapt declares a virtual \cod{dbl2int()} method for the
inverse operation.  There are also \cod{dbl2dbl()} methods which operate on the double
values after conversion from integer and prior to converting to integer, respectively.
The conversion is broken up into two steps (\cod{int2dbl}/\cod{dbl2dbl}) so that
registers which already present floating-point encoded values (and which thus
don't require \cod{int2dbl}) can still be transformed.

The default implementation just performs a one-to-one transformation. These methods are
thus obvious candidates to be overridden, extending the functionality from a one-to-one
relation to an arbitrary linear transformation with configurable ``scale'' and
``offset'' parameters. These parameters are to be extracted from \yaml{} and this is
the job of an associated class, CInt2Dbl, which derives from CIntEntryImpl.
\figr{int2dbl} shows the new classes and how they derive from existing ones.

\begin{figure}[htb]
\fig{0.9\textwidth}{O.Common/int2dbl.pdf}
\label{fig:int2dbl}
\caption{New classes to support integer to floating-point conversion. The adapters
CInt2Dbl\_ROAdapt and CInt2Dbl\_WOAdapt override the actual conversion methods.
CInt2Dbl holds the conversion parameters (scale/offset) which are extracted
from \yaml{}.}
\end{figure}

\subsection{Implementation}
Study the implementation in the files \cod{int2dbl.h} and \cod{int2dbl.cc}.
The header reflects the inheritance relationship depicted in \figr{int2dbl}.

The CInt2Dbl class adds members for scale and offset to what CIntEntryImpl
already provides. There is some boilerplate code:
\begin{itemize}
\item Every subclass of Entry should implement a copy constructor and a \cod{clone()}
      method which invokes this copy constructor. \cod{clone()} receives a special
      {\em Key} argument which is a guard against direct execution of \cod{clone()}
      by the user. \cod{clone()} must only be used by \cpsw{} internally since the
      return value must be properly wrapped into a {\em shared pointer} before it
      is handed to the user. {\em Key} objects cannot be created publicly and since
      a {\em Key} is required to call \cod{clone()} the {\em Key} object helps to
      assert fine-grained access control. You'll find this idiom at several places
      in \cpsw{}.
\item Every subclass of Entry must define a \cod{static} \cod{\_getClassName()}
      method which returns the (unique!) name of the class as it is to be used
      by the ``class'' property in \yaml{}. The shared object into which the new
      class (along with its {\em Adapters}) is to be built {\em must bear the same name}
      so that it can be located by the dynamic linker.
\item A virtual method \cod{getClassName()} must be added. It should just 
      call \cod{\_getClassName()} so that the class name can be obtained in a polymorphic
      fashion (the \cod{static} version is required by the class registry -- since
      no object of the class exists {\em a-priory} the registry must use the
      \cod{static} method).
\item Every subclass of Entry must provide a constructor which takes a {\em Key}
      and a YamlState argument. This is what allows construction of objects from
      \yaml{}. The constructor extracts all relevant parameters from YamlState 
      with \cod{readNode()}.
\item \cod{dumpYamlPart()} is responsible for storing member values into a \yaml{}
      node permitting a hierarchy which was created with the builder API to be saved
      in \yaml{} format. It does the inverse operation of the constructor.
\item \cod{createAdapter()} is the factory method which creates an object of the
      Entry's associated {\em Adapter} class. It is being passed a \cod{std::type\_info}
      reference which identifies the {\em interface} the user wants to create.
      The method should inspect this argument and decide if any {\em Adapter}
      implements the desired interface and create a new {\em Adapter} object if this
      is the case. Otherwise, the method should chain to the superclass (it may also
      decide {\em not} to defer to the superclass if it doesn't want to expose the
      more generic features of the superclass).
\item Every subclass of Entry should add itself to the \cpsw{} class registry by
      expanding the macro \cod{DECLARE\_YAML\_FIELD\_FACTORY()}. Note that this
      macro must be expanded from a file which is being linked (not an issue if
      shared libraries or shared objects are used; the note applies to the situation
      where the extension classes are residing in a static library).
\end{itemize}
The most interesting pieces are the constructor from \yaml{} and the \cod{createAdapter()}
method.

The methods \cod{int2dbl()} and \cod{dbl2int()} which compute the actual conversions
are rather trivial.
Note how they fetch the conversion parameters from the associated CInt2Dbl object.

It is also noteworthy that the conversion routines in this example do {\em not} make
use of any information held by the {\em Adapter} class. Thus, it would in theory be
possible to forego the business of {\em Adapters} -- the converters could just have
been members of CIntEntryImpl. However, imagine you would want to implement a similar
class but this time the scale factor should be read from another ScalVal somewhere in
the hierarchy -- the current design would allow you to do that and you would then
store the necessary \Path{} and/or ScalVal references in the {\em Adapter} object.

\subsection{The ``makefile''}
Add the following lines to the \cod{makefile} in the tutorial top directory. This
will result in a shared object \cod{Int2Dbl.so} being built (after typing \cod{make}). 
\begin{verbatim}
SHARED_OBJS     += Int2Dbl.so
Int2Dbl_so_SRCS += int2dbl.cc
Int2Dbl_so_LIBS  = $(CPSW_LIBS)
\end{verbatim}
In order for the shared object to be found in the \cod{LD\_LIBRARY\_PATH} defined
by \cod{env.slac} the object must be installed (\cod{make install}).

For more information about the \cpsw{} makefile system consult \cite{makefile, INSTALL}.

\subsection{Cleaning Up ``ModelParm.py''}
If you look at \cod{pendsimRegs.yaml} again then you will see that the `class' property
of the individual registers is actually a {\em sequence} which lists multiple classes 
which could possibly support the registers.
Since we hadn't actually built `Int2Dbl' \cpsw{} was unable to locate this class and
fell back on a regular `IntField'. Now, however -- assuming that the LD\_LIBRARY\_PATH
is set up correctly -- the dynamic linker should be able to locate our new Int2Dbl.so
and use it according to the algorithm explained above.

Since all of the scaling is now taken care of transparently you can copy the 
ModelParm.py file to a new version: ModelParmScaled.py. Open this new file in your
editor and remove all the code which does compute the scaled values.
The ModelParm class should be trivially simple now.

Next, edit UdpsrvInterface.py and close to the top modify the \cod{import} 
command to use ModelParmScaled.py instead of ModelParm.py:
\begin{verbatim}
import ModelParmScaled as ModelParm
\end{verbatim}
Launch the TutorialGui.py again and verify that it is working.

\subsection{Controller}
If you initialize the pendulum position so that it is approximately vertical
then you will notice that it will ``magically'' stabilize at $\varphi=\pi/2, x=0$.

tutorialGui.py implements a trivial state-space controller (based on the
default parameters of the simulation). The controller uses a linear approximation
which is only suitable as long as the pendulum does not deviate too far
from $\varphi=\pi/2$. If the excursion exceeds a limit then the controller
is disabled.

It is left to the reader to add Gui elements to interact with the controller
and/or to improve the algorithm. The reader could also try to port the controller
to a \cpp{} class which shall be bound to the `pendsim' device transparently.
(Hint: the driver could derive from MMIODev and its {\em Adapter} class
could hold DoubleVal and Stream references and interact with these. The 
\yaml{} 'class' property of the pendsim device could list the new driver
class.)

\section{Solutions to Exercises}
Check out the `solutions' branch from \git{}.

\section{Further Reading}

\begin{thebibliography}{9}
\bibitem{INSTALL}
framework/src/doc/INSTALL[.html],\\
``HowTo'' build \cpsw{}.
\bibitem{userapi}
framework/src/cpsw\_api\_user.h,\\
The \cpsw{} ``user'' API.
\bibitem{yaml}
http://www.yaml.org/spec/1.2/spec.html,\\
Specification of the \yaml{} syntax.
\bibitem{yamlDefinition}
framework/src/doc/README.yamlDefinition[.html],\\
description of \yaml{} as used by \cpsw{}; definition of preprocessor directives.
\bibitem{myCommand}
framework/src/test/cpsw\_myCommand.cc,\\
example for implementation of a custom command.
\bibitem{makefile}
framework/src/makefile.template,\\
template for a makefile using \cpsw{}'s makefile system.
\bibitem{FWLoader}
FirmwareLoader,\\
A \cpsw{} application which adds new classes to \cpsw{}. Residing in its own
\cod{git} repository\\
/afs/slac/g/cd/swe/git/repos/package/cpsw/FirmwareLoader.git
\end{thebibliography}

\end{document}

